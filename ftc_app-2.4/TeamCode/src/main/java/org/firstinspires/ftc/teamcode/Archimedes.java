package org.firstinspires.ftc.teamcode;import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;import com.qualcomm.robotcore.hardware.ColorSensor;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.DcMotorSimple;import com.qualcomm.robotcore.hardware.GyroSensor;import com.qualcomm.robotcore.hardware.OpticalDistanceSensor;import com.qualcomm.robotcore.hardware.Servo;import com.qualcomm.robotcore.util.ElapsedTime;import com.qualcomm.robotcore.util.Range;/** * The Archimedes class contains all the methods that run the robot for the * 2016-2017 robot for the FTC team #5037 got robot? * * @author got robot? * @version 2.2 * @since 2017-01-20 */abstract class Archimedes extends LinearOpMode{	final double DEFAULT_DRIVE_SPEED = 1.0;	final double DEFAULT_TURN_SPEED = 0.85;	private final double MINIMUM_DRIVE_POWER = .15;	private final int ENCODER_UNITS_PER_REVOLUTION = 1440;	private final double ENCODER_WHEEL_DIAMETER = 50.2;	private final double ENCODER_UNITS_PER_MILLIMETER =			(ENCODER_UNITS_PER_REVOLUTION /					(ENCODER_WHEEL_DIAMETER * Math.PI));	DcMotor leftMotor;	DcMotor rightMotor;	private DcMotor ballLauncher_;	private DcMotor ballCollector_;	private DcMotor liftMotor1;	private DcMotor liftMotor2;	private Servo ballDeployer_;	private Servo capBallGrabber_;	private Servo buttonPusher_;	private ColorSensor colorSensor_;	private ModernRoboticsI2cRangeSensor leftRangeSensor_;	private ModernRoboticsI2cRangeSensor rightRangeSensor_;	private OpticalDistanceSensor leftCenterOds_;	private OpticalDistanceSensor rightCenterOds_;	private OpticalDistanceSensor leftOutsideOds_;	private OpticalDistanceSensor rightOutsideOds_;	private GyroSensor gyroSensor_;	private int lastRawGyroHeading_ = 0;	private int gyroHeading_ = 0;	private int targetGyroHeading_ = 0;	private ElapsedTime elapsedTime_ = new ElapsedTime();	void startArchimedes()	{		if (opModeIsActive())		{			telemetry.addData(">", "Archimedes running...");			telemetry.update();		}	}	/**	 * Sets the power for both lift motors	 *	 * @param power The power the lift should run at.	 */	void setLiftPower(double power)	{		if (opModeIsActive())		{			liftMotor1.setPower(-power);			liftMotor2.setPower(liftMotor1.getPower());		}	}	void startBallCollector()	{		if (opModeIsActive())		{			ballCollector_.setPower(1);		}	}	void stopBallCollector()	{		if (opModeIsActive())		{			ballCollector_.setPower(0);		}	}	void reverseBallCollector()	{		if (opModeIsActive())		{			ballCollector_.setPower(-1);		}	}	/**	 * Initializes all of the motors, servos and sensors. Also beings	 * calibrating the gyro sensor.	 */	void initializeArchimedes()	{		if (opModeIsActive())		{			leftMotor = hardwareMap.dcMotor.get("left motor");			leftMotor.setDirection(DcMotor.Direction.REVERSE);			leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);			rightMotor = hardwareMap.dcMotor.get("right motor");			rightMotor.setDirection(DcMotor.Direction.FORWARD);			rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);			ballLauncher_ = hardwareMap.dcMotor.get("ball launcher");			ballLauncher_.setDirection(DcMotor.Direction.REVERSE);			ballLauncher_.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);			ballLauncher_.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			ballLauncher_.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);			ballCollector_ = hardwareMap.dcMotor.get("ball collector");			ballCollector_.setDirection(DcMotor.Direction.REVERSE);			ballCollector_.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			liftMotor1 = hardwareMap.dcMotor.get("lift motor 1");			liftMotor1.setDirection(DcMotorSimple.Direction.FORWARD);			liftMotor2 = hardwareMap.dcMotor.get("lift motor 2");			liftMotor2.setDirection(DcMotorSimple.Direction.FORWARD);			capBallGrabber_ = hardwareMap.servo.get("cap ball grabber");			capBallGrabber_.setDirection(Servo.Direction.FORWARD);			dropCapBallGrabber();			buttonPusher_ = hardwareMap.servo.get("button pusher");			buttonPusher_.setDirection(Servo.Direction.FORWARD);			setButtonPusherToNeutral();			ballDeployer_ = hardwareMap.servo.get("ball deployer");			ballDeployer_.setDirection(Servo.Direction.FORWARD);			dropBallDeployer();			colorSensor_ = hardwareMap.colorSensor.get("color sensor");			leftRangeSensor_ = hardwareMap					.get(ModernRoboticsI2cRangeSensor.class, "left range " +							"sensor");			rightRangeSensor_ = hardwareMap					.get(ModernRoboticsI2cRangeSensor.class, "right range " +							"sensor");			leftCenterOds_ =					hardwareMap.opticalDistanceSensor.get("left center ODS");			rightCenterOds_ =					hardwareMap.opticalDistanceSensor.get("right center ODS");			leftOutsideOds_ =					hardwareMap.opticalDistanceSensor.get("left outside ODS");			rightOutsideOds_ =					hardwareMap.opticalDistanceSensor.get("right outside ODS");			gyroSensor_ = hardwareMap.gyroSensor.get("gyro");			gyroSensor_.calibrate();		}	}	void dropCapBallGrabber()	{		if (opModeIsActive())		{			capBallGrabber_.setPosition(0);		}	}	void setButtonPusherToNeutral()	{		if (opModeIsActive())		{			buttonPusher_.setPosition(.3);		}	}	void dropBallDeployer()	{		if (opModeIsActive())		{			ballDeployer_.setPosition(1);		}	}	void startBallLauncherForAutonomous()	{		if (opModeIsActive())		{			ballLauncher_.setPower(0.55);		}	}	void startBallLauncherForTeleop()	{		if (opModeIsActive())		{			ballLauncher_.setPower(.75);		}	}	void stopBallLauncher()	{		ballLauncher_.setPower(0.0);	}	void clampCapBallGrabber()	{		if (opModeIsActive())		{			capBallGrabber_.setPosition(0.5);		}	}	void liftCapBallGrabber()	{		if (opModeIsActive())		{			capBallGrabber_.setPosition(0.85);		}	}	/**	 * Tells the robot to drive forward a set distance. Slows down as it gets	 * closer to the set distance. Also corrects its self if using the gyro	 * sensor if it starts to drift.	 *	 * @param power    The maximum power the robot will drive.	 * @param distance The distance the robot should drive in cm.	 *	 * @see #getGyroPowerAdjustment()	 * @see #getDrivePower(double, double)	 */	void drive(double power, int distance)	{		final double encoderUnitsToDrive = ENCODER_UNITS_PER_MILLIMETER *				distance;		double leftAdjustedPower;		double rightAdjustedPower;		if (opModeIsActive())		{			leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			while (!isDriveDistanceReached(encoderUnitsToDrive) &&					opModeIsActive())			{				leftAdjustedPower = Range.clip(						getDrivePower(encoderUnitsToDrive, power) -								getGyroPowerAdjustment(), -1, 1);				rightAdjustedPower = Range.clip(						getDrivePower(encoderUnitsToDrive, power) +								getGyroPowerAdjustment(), -1, 1);				leftMotor.setPower(leftAdjustedPower);				rightMotor.setPower(rightAdjustedPower);				idle();				sleep(50);			}		}		stopDriveMotors();	}	/**	 * Tells when the distace the robot was driving for was reached.	 * @param driveDistance The target distance the robot was driving for.	 * @return True if the distance has been reached.	 */	private boolean isDriveDistanceReached(double driveDistance)	{		return Math.abs(getEncoderWheel().getCurrentPosition()) >=				Math.abs(driveDistance);	}	private DcMotor getEncoderWheel()	{		return rightMotor;	}	private double getGyroPowerAdjustment()	{		final double GYRO_DRIVE_COEFFICIENT = 0.04;		return (targetGyroHeading_ - getGyroHeading()) * GYRO_DRIVE_COEFFICIENT;	}	/**	 * Calculate the gyro headingby taking the raw gyro heading taken from	 * the sensor and converting it into a more usable value.	 * @return The gyro heading.	 */	private int getGyroHeading()	{		int rawGyroHeading = gyroSensor_.getHeading();		// 0->360		if (rawGyroHeading - 180 > lastRawGyroHeading_)		{			gyroHeading_ =					gyroHeading_ + rawGyroHeading - 360 -							lastRawGyroHeading_;		}		// 359->0		else if (rawGyroHeading + 180 < lastRawGyroHeading_)		{			gyroHeading_ =					gyroHeading_ + rawGyroHeading + 360 -							lastRawGyroHeading_;		}		else		{			gyroHeading_ =					gyroHeading_ + rawGyroHeading - lastRawGyroHeading_;		}		lastRawGyroHeading_ = rawGyroHeading;		return gyroHeading_;	}	/**	 * Stops both drive motors and resets the encoder wheel.	 */	private void stopDriveMotors()	{		leftMotor.setPower(0);		rightMotor.setPower(0);		getEncoderWheel().setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);	}	/**	 * Generates a parabolic function and slows the robot down while driving	 * forwards or backwards using the parameters.	 *	 * @param driveDistance The distance that the robot is attempting to drive.	 * @param power         The maximum power the robot should drive at.	 *	 * @return The power that the robot should drive at.	 */	private double getDrivePower(double driveDistance, double power)	{		double adjustedPower = ((1 - MINIMUM_DRIVE_POWER) - (1 - power)) *				Math.pow(1 - Math.abs(						getEncoderWheel().getCurrentPosition() / driveDistance),						2) + MINIMUM_DRIVE_POWER;		if (driveDistance > 0)		{			return Range.clip(adjustedPower, MINIMUM_DRIVE_POWER, power);		}		else		{			return Range.clip(-adjustedPower, -power, -MINIMUM_DRIVE_POWER);		}	}	/**	 * Uses a combination of the gyro sensor, the range sensor and the	 * optical distance sesnor and weights them baced on their importance to	 * try to line up with the wall.	 * @return The weighted drive correction.	 */	private double getWeightedDriveCorrection()	{		// TODO Check to see if these weights produce a result that is expected		final double RANGE_SENSOR_WEIGHT = 0.15;		final double GYRO_SENSOR_WEIGHT = 0.15;		final double ODS_WEIGHT = 0.7;		return (getRangeSensorPowerAdjustment() * RANGE_SENSOR_WEIGHT) +				(getGyroPowerAdjustment() * GYRO_SENSOR_WEIGHT) +				(getOdsPowerAdjustment() * ODS_WEIGHT);	}	private double getOdsPowerAdjustment()	{		final double OPTICAL_DISTANCE_SENSOR_COEFFICIENT = 0.65;		return (rightCenterOds_.getLightDetected() -				leftCenterOds_.getLightDetected()) *				OPTICAL_DISTANCE_SENSOR_COEFFICIENT;	}	private double getRangeSensorPowerAdjustment()	{		// TODO Check to see if this coefficient is a good value		final double RANGE_SENSOR_COEFFICIENT = 0.025;		return (rightRangeSensor_.cmUltrasonic() -				leftRangeSensor_.cmUltrasonic()) *				RANGE_SENSOR_COEFFICIENT;	}	/**	 * Drives the robot until it finds a line and then drives slightly	 * farther. Slows down as it gets closer to the point where the line is	 * expected. Also uses gyro correction to correct the drive if it drifts.	 *	 * @param power              The maximum power the robot should drive at	 * @param maxDistance        The maximum distance the robot should drive before	 *                           stopping.	 * @param lightThreshold     The threshold in which the robot detects a line	 *                           and stops.	 * @param afterDriveDistance The distance the robot should drive after it	 *                           finds the line.	 *	 * @see #getGyroPowerAdjustment()	 * @see #getDrivePower(double, double)	 */	void driveToLine(double power, int maxDistance, double lightThreshold,	                 int afterDriveDistance)	{		final double encoderUnitsToDrive = ENCODER_UNITS_PER_MILLIMETER *				maxDistance;		final double afterDriveEncoderUnitsToDrive =				ENCODER_UNITS_PER_MILLIMETER *						afterDriveDistance;		final double combinedDistance = encoderUnitsToDrive +				afterDriveEncoderUnitsToDrive;		double leftAdjustedPower;		double rightAdjustedPower;		if (opModeIsActive())		{			getEncoderWheel().setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			while (!isDriveDistanceReached(encoderUnitsToDrive) &&					!isLineDetected(lightThreshold) && opModeIsActive())			{				leftAdjustedPower =						Range.clip(getDrivePower(combinedDistance, power) -								getGyroPowerAdjustment										(), -1, 1);				rightAdjustedPower =						Range.clip(getDrivePower(combinedDistance, power) +								getGyroPowerAdjustment(), -1, 1);				leftMotor.setPower(leftAdjustedPower);				rightMotor.setPower(rightAdjustedPower);				idle();				sleep(50);			}			while (!isDriveDistanceReached(combinedDistance) &&					opModeIsActive())			{				leftAdjustedPower =						Range.clip(getDrivePower(combinedDistance, power) -								getGyroPowerAdjustment(), -1, 1);				rightAdjustedPower =						Range.clip(getDrivePower(combinedDistance, power) +								getGyroPowerAdjustment(), -1, 1);				leftMotor.setPower(leftAdjustedPower);				rightMotor.setPower(rightAdjustedPower);				idle();				sleep(50);			}		}		stopDriveMotors();	}	/**	 * Tells if a light has been detected by the optical distance sensors. In	 * almost every case this will be used for detecting the lines in front	 * of the beacons.	 * @param lightThreshold The light threshold that a line has been detected.	 * @return True if a line has been detected.	 */	private boolean isLineDetected(double lightThreshold)	{		return leftCenterOds_.getLightDetected() > lightThreshold &&				rightCenterOds_.getLightDetected() > lightThreshold;	}	/**	 * Follows the line that is in front of the beacons up to the wall. Slows	 * down as it gets closer to the wall.	 *	 * @param power            The maximum power the robot should drive at.	 * @param distanceFromWall The distance from the wall the robot should	 *                         stop at.	 *	 * @see #getOdsPowerAdjustment()	 * @see #getRangeDrivePower(double, double, double)	 */	void followBeaconLineToWall(double power, int distanceFromWall)	{		double leftAdjustedPower;		double rightAdjustedPower;		if (opModeIsActive())		{			final int startingDistanceFromWall = getAverageRangeSensorCm();			leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			while (!isWallInRangeThreshold(distanceFromWall)					&& opModeIsActive())			{				leftAdjustedPower = Range.clip(						getRangeDrivePower(startingDistanceFromWall,								distanceFromWall, power) -								getOdsPowerAdjustment(), -1,						1);				rightAdjustedPower = Range.clip(						getRangeDrivePower(startingDistanceFromWall,								distanceFromWall, power) +								getOdsPowerAdjustment(), -1,						1);				leftMotor.setPower(leftAdjustedPower);				rightMotor.setPower(rightAdjustedPower);				idle();				sleep(50);			}		}		stopDriveMotors();	}	/**	 * @param startingDistanceFromWall	 * @param targetEndDistance	 * @param power	 *	 * @return	 */	private double getRangeDrivePower(double startingDistanceFromWall,	                                  double targetEndDistance, double power)	{		// TODO Make sure this works as intended		double adjustedPower = ((1 - MINIMUM_DRIVE_POWER) - (1 - power)) *				Math.pow(1 - (getAverageRangeSensorCm						() / startingDistanceFromWall), 2) +				MINIMUM_DRIVE_POWER;		return Range.clip(adjustedPower, MINIMUM_DRIVE_POWER, power);	}	private int getAverageRangeSensorCm()	{		// TODO Make sure this works as intended		return (int) (Math.round(leftRangeSensor_.cmUltrasonic() +				rightRangeSensor_						.cmUltrasonic()) / 2);	}	private boolean isWallInRangeThreshold(int threshold)	{		return getAverageRangeSensorCm() <= threshold;	}	void turnButtonPusherRight()	{		if (opModeIsActive())		{			buttonPusher_.setPosition(0);		}	}	void launchBall(int delay)	{		if (opModeIsActive())		{			liftBallDeployer();		}		sleep(delay);		dropBallDeployer();	}	void liftBallDeployer()	{		if (opModeIsActive())		{			ballDeployer_.setPosition(.75);		}	}	/**	 * Sleeps until the gyro is done calibrating	 */	void waitForGyroCalibration()	{		telemetry.addData(">", "Calibrating gyro...");		telemetry.update();		sleep(1000);		while (gyroSensor_.isCalibrating() && !isStopRequested())		{			idle();			sleep(50);		}		telemetry.addData(">", "Archimedes ready!");		telemetry.update();	}	boolean isDetectingBlueOnRight()	{		return colorSensor_.blue() > colorSensor_.red();	}	boolean isDetectingRedOnRight()	{		return colorSensor_.blue() < colorSensor_.red();	}	/**	 * Turns the robot by a set amount of degrees. Slows down as it gets	 * closer to the target heading.	 *	 * @param power       The maximum power that the robot should drive at.	 * @param angleChange The amount of degrees that the robot should turn.	 *	 * @see #getTurnPower(double, double)	 */	void turn(double power, int angleChange)	{		if (opModeIsActive())		{			rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			changeTargetGyroHeading(angleChange);			while (!isHeadingReached(angleChange) && opModeIsActive())			{				double turnPower = getTurnPower(angleChange, power);				leftMotor.setPower(-turnPower);				rightMotor.setPower(turnPower);			}		}		stopDriveMotors();	}	private boolean isHeadingReached(double heading)	{		if (heading > 0)		{			return (getGyroHeading() > targetGyroHeading_);		}		else		{			return (getGyroHeading() < targetGyroHeading_);		}	}	/**	 * Generates a parabolic function that slows down that robot as it gets	 * closer to its target heading when turning.	 *	 * @param angleChange The amount of degrees that the robot it turning.	 * @param power       The maximum power the robot should turn at.	 *	 * @return The power the robot should turn at.	 */	private double getTurnPower(double angleChange, double power)	{		final double MINIMUM_TURN_POWER = 0.35;		double adjustedPower = ((1 - MINIMUM_TURN_POWER) - (1 - power)) *				Math.pow((Math.abs(						targetGyroHeading_ - getGyroHeading()) /								Math.abs(angleChange)),						2) + MINIMUM_TURN_POWER;		if (angleChange > 0)		{			return Range.clip(adjustedPower, MINIMUM_TURN_POWER, power);		}		else		{			return Range.clip(-adjustedPower, -power, -MINIMUM_TURN_POWER);		}	}	private void changeTargetGyroHeading(int headingChange)	{		targetGyroHeading_ += headingChange;	}	private void setTargetGyroHeading(int heading)	{		targetGyroHeading_ = heading;	}	void turnButtonPusherLeft()	{		if (opModeIsActive())		{			buttonPusher_.setPosition(.6);		}	}	/**	 * Drives for a set amount of time.	 *	 * @param power The power the robot should drive at.	 * @param time  The time in milliseconds that the robot should drive for.	 */	void timeDrive(double power, int time)	{		if (opModeIsActive())		{			leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);			leftMotor.setPower(power);			rightMotor.setPower(power);			double startTime = elapsedTime_.milliseconds();			while (startTime + time > elapsedTime_.milliseconds() &&					opModeIsActive())			{				sleep(50);				idle();			}		}		stopDriveMotors();	}	boolean isAlignedWithBeacon()	{		// TODO Find good values for these thresholds		final int GYRO_ALIGNMENT_THRESHOLD = 2;		final int ULTRASONIC_ALIGNMENT_THRESHOLD = 2;		final double LINE_THRESHOLD = 1.5;		boolean isGyroAlignedWithWall = Math.abs(getGyroHeading()) % 90 <=				GYRO_ALIGNMENT_THRESHOLD;		boolean isUltrasonicAlignedWithWall = Math.abs(leftRangeSensor_				.cmUltrasonic() - rightRangeSensor_.cmUltrasonic()) <=				ULTRASONIC_ALIGNMENT_THRESHOLD;		return isGyroAlignedWithWall && isUltrasonicAlignedWithWall &&				isLineDetected(LINE_THRESHOLD);	}}