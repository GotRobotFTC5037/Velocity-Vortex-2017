package org.firstinspires.ftc.teamcode;import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;import com.qualcomm.robotcore.hardware.ColorSensor;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.DcMotorSimple;import com.qualcomm.robotcore.hardware.GyroSensor;import com.qualcomm.robotcore.hardware.OpticalDistanceSensor;import com.qualcomm.robotcore.hardware.Servo;import com.qualcomm.robotcore.hardware.TouchSensor;import com.qualcomm.robotcore.util.ElapsedTime;import com.qualcomm.robotcore.util.Range;/** * The Archimedes class contains all the methods that run the robot for the * 2016-2017 robot for the FTC team #5037 got robot? * * @author got robot? * @version 3.0 * @since 2017-01-31 */abstract class Archimedes extends LinearOpMode{    static final int DEFAULT_WALL_DISTANCE = 9;    static final double MINIMUM_DRIVE_POWER = 0.165;    static final double MINIMUM_TURN_POWER = 0.525;    static final double MAXIMUM_LIFT_HEIGHT = 26800;    static final double MAXIMUM_SLOW_POWER_DRIVE = 0.30;    static final double MAXIMUM_SLOW_POWER_TURN = 0.6;    static final int POST_LINE_DISTANCE_BLUE = 85;    static final int POST_LINE_DISTANCE_RED = 50;    private static final int MAXIMUM_COLOR_SENSOR_WAIT_TIME = 1000;    private static final double DEFAULT_LINE_THRESHOLD = 0.15;    private static final int COLOR_DETECTION_THRESHOLD = 5;    private static final int MINIMUM_WALL_DISTANCE = 4;    private static final int DEFAULT_TURN_THRESHOLD = 3;    private static final int MAXIMUM_GYRO_ERROR = 6;    private static final double GYRO_DRIVE_COEFFICIENT = 0.04;    private static final double ODS_COEFFICIENT = 0.65;    private static final double DISTANCE_BETWEEN_ODS_SENSORS = 213;    private static final double ANGLE_BETWEEN_ODS_SENSORS = 34;    private static final int COUNTS_PER_REVOLUTION = 1440;    private static final double ENCODER_WHEEL_DIAMETER = 50.2;    private static final double COUNTS_PER_MILLIMETER =            COUNTS_PER_REVOLUTION / (ENCODER_WHEEL_DIAMETER * Math.PI);    private static final double BALL_LAUNCHER_CIRCUMFERENCE = 0.4289059370313465;    private static final double BALL_LAUNCHER_GEAR_RATIO = 20;    private static final double BALL_LAUNCHER_SPEED_COEFFICIENT = BALL_LAUNCHER_CIRCUMFERENCE *            BALL_LAUNCHER_GEAR_RATIO;    private final ElapsedTime mElapsedTime = new ElapsedTime();    private int mLastRawGyroHeading = 0;    private int mGyroHeading = 0;    private int mTargetGyroHeading = 0;    private double mTargetBallLauncherSpeed = 0.0;    private double mBallLauncherSpeed = 0.0;    private double mBallLauncherAcceleration = 0.0;    private DcMotor mLeftDriveMotor;    private DcMotor mRightDriveMotor;    private DcMotor mBallLauncher;    private DcMotor mBallCollector;    private DcMotor mLiftMotor1;    private DcMotor mLiftMotor2;    private Servo mBallDeployer;    private Servo mCapBallGrabber;    private Servo mButtonPusher;    private ModernRoboticsI2cRangeSensor mLeftRangeSensor;    private OpticalDistanceSensor mLeftOds;    private OpticalDistanceSensor mRightOds;    private OpticalDistanceSensor mFrontLeftOds;    private OpticalDistanceSensor mFrontRightOds;    private ColorSensor mColorSensor;    private TouchSensor mLiftSensor;    private GyroSensor mGyroSensor;    // Robot Setup    /**     * Initializes all of the motors, servos and sensors. Also beings     * calibrating the gyro sensor.     */    void initializeArchimedes()    {        mLeftDriveMotor = hardwareMap.dcMotor.get("left motor");        mLeftDriveMotor.setDirection(DcMotor.Direction.REVERSE);        mLeftDriveMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mLeftDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        mRightDriveMotor = hardwareMap.dcMotor.get("right motor");        mRightDriveMotor.setDirection(DcMotor.Direction.FORWARD);        mRightDriveMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mRightDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        mBallLauncher = hardwareMap.dcMotor.get("ball launcher");        mBallLauncher.setDirection(DcMotor.Direction.REVERSE);        mBallLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mBallLauncher.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        mBallLauncher.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);        mBallCollector = hardwareMap.dcMotor.get("ball collector");        mBallCollector.setDirection(DcMotor.Direction.REVERSE);        mBallCollector.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        mLiftMotor1 = hardwareMap.dcMotor.get("lift motor 1");        mLiftMotor1.setDirection(DcMotorSimple.Direction.REVERSE);        mLiftMotor2 = hardwareMap.dcMotor.get("lift motor 2");        mLiftMotor2.setDirection(DcMotorSimple.Direction.REVERSE);        mCapBallGrabber = hardwareMap.servo.get("cap ball grabber");        mCapBallGrabber.setDirection(Servo.Direction.FORWARD);        dropCapBallGrabber();        mButtonPusher = hardwareMap.servo.get("button pusher");        mButtonPusher.setDirection(Servo.Direction.FORWARD);        setButtonPusherPosition(ButtonPusherPosition.NEUTRAL_POSITION);        mBallDeployer = hardwareMap.servo.get("ball deployer");        mBallDeployer.setDirection(Servo.Direction.FORWARD);        dropBallDeployer();        mColorSensor = hardwareMap.colorSensor.get("color sensor");        mColorSensor.enableLed(false);        mLeftRangeSensor = hardwareMap                .get(ModernRoboticsI2cRangeSensor.class, "left range sensor");        mLeftOds =                hardwareMap.opticalDistanceSensor.get("left ODS");        mRightOds =                hardwareMap.opticalDistanceSensor.get("right ODS");        mFrontLeftOds =                hardwareMap.opticalDistanceSensor.get("front left ODS");        mFrontRightOds =                hardwareMap.opticalDistanceSensor.get("front right ODS");        mLiftSensor = hardwareMap.touchSensor.get("lift sensor");        mGyroSensor = hardwareMap.gyroSensor.get("gyro");        mGyroSensor.calibrate();    }    /**     * Sleeps until the gyro is done calibrating     */    void waitForGyroCalibration()    {        telemetry.addData(">", "Calibrating gyro...");        telemetry.update();        idle();        sleep(1000);        while (mGyroSensor.isCalibrating() && !isStopRequested())        {            idle();        }        telemetry.addData(">", "Archimedes ready!");        telemetry.update();    }    void startArchimedes()    {        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            telemetry.addData(">", "Archimedes running...");            telemetry.update();            mGyroSensor.resetZAxisIntegrator();        }    }    // Movement    /**     * Tells the robot to drive forward a set distance. Slows down as it gets     * closer to the set distance. Also corrects its self if using the gyro     * sensor if it starts to drift.     *     * @param power    The maximum power the robot will drive.     * @param distance The distance the robot should drive in cm.     *     * @see #getGyroPowerAdjustment()     */    void drive(final double power, final int distance, final int slowDownThreshold)    {        final int encoderDistance = (int) Math.round(distance * COUNTS_PER_MILLIMETER);        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isDriveDistanceReached(encoderDistance) &&                    opModeIsActive())            {                final double leftMotorPower;                final double rightMotorPower;                leftMotorPower = getDrivePower(power, encoderDistance, slowDownThreshold) -                        getGyroPowerAdjustment();                rightMotorPower = getDrivePower(power, encoderDistance, slowDownThreshold) +                        getGyroPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);                idle();            }        }        stopDriveMotors();    }    /**     * Turns the robot by a set amount of degrees. Slows down as it gets     * closer to the target heading.     *     * @param power       The maximum power that the robot should drive at.     * @param angleChange The amount of degrees that the robot should turn.     *     * @see #getTurnPower(double, double)     */    void turn(final double power, final int angleChange)    {        if (opModeIsActive())        {            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            changeTargetGyroHeading(angleChange);            while (!isHeadingReached(angleChange, DEFAULT_TURN_THRESHOLD) && opModeIsActive())            {                final double turnPower = getTurnPower(power, angleChange);                mLeftDriveMotor.setPower(-turnPower);                mRightDriveMotor.setPower(turnPower);            }        }        stopDriveMotors();    }    /**     * Drives the robot until it finds a line and then drives slightly     * farther. Slows down as it gets closer to the point where the line is     * expected. Also uses gyro correction to correct the drive if it drifts.     *     * @param power           The maximum power the robot should drive at     * @param maximumDistance The maximum distance the     *                        robot should drive before stopping.     *     * @see #getGyroPowerAdjustment()     */    void driveToLine(final double power, final int maximumDistance,                     final int slowdownThreshold, final int postLineDistance)    {        final int maxEncoderDistance = (int) Math.round(COUNTS_PER_MILLIMETER * maximumDistance);        if (opModeIsActive())        {            int adjustedPostLineDist = 0;            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isDriveDistanceReached(maxEncoderDistance) &&                    !isLineDetected(DEFAULT_LINE_THRESHOLD) && opModeIsActive())            {                final double leftMotorPower;                final double rightMotorPower;                leftMotorPower = getDrivePower(power, maxEncoderDistance, slowdownThreshold) -                        getGyroPowerAdjustment();                rightMotorPower = getDrivePower(power, maxEncoderDistance, slowdownThreshold) +                        getGyroPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);                if (getEncoderWheel().getCurrentPosition() > maxEncoderDistance / 8)                {                    if (isLineDetected(DEFAULT_LINE_THRESHOLD))                    {                        adjustedPostLineDist = postLineDistance;                        break;                    }                    else if (isLineDetectedOnEdge(DEFAULT_LINE_THRESHOLD / 3))                    {                        adjustedPostLineDist = computeAdjustedPostLineDistance();                        adjustedPostLineDist += postLineDistance;                        break;                    }                }            }            idle();            adjustedPostLineDist = (int) Math.round(adjustedPostLineDist * COUNTS_PER_MILLIMETER);            final int totalDriveDistance =                    Math.round(getEncoderWheel().getCurrentPosition() + adjustedPostLineDist);            while (!isDriveDistanceReached(totalDriveDistance) && opModeIsActive())            {                final double leftMotorPower;                final double rightMotorPower;                leftMotorPower = getDrivePower(power, totalDriveDistance, slowdownThreshold) -                        getGyroPowerAdjustment();                rightMotorPower = getDrivePower(power, totalDriveDistance, slowdownThreshold) +                        getGyroPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);                idle();            }        }        stopDriveMotors();    }    /**     * Follows the line that is in front of the beacons up to the wall. Slows     * down as it gets closer to the wall.     *     * @param power        The maximum power the robot should drive at.     * @param wallDistance The distance from the wall the robot should     *                     stop at.     *     * @see #getOdsPowerAdjustment()     * @see #getRangeDrivePower(double, double, double)     */    void followLineToWall(final double power, final int wallDistance)    {        if (opModeIsActive())        {            final double startingWallDistance = mLeftRangeSensor.cmUltrasonic();            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            double targetPosition = getEncoderWheel().getCurrentPosition() +                    (5 * COUNTS_PER_MILLIMETER);            double startTime = mElapsedTime.milliseconds();            while (!isWallWithinRangeThreshold(wallDistance) && opModeIsActive())            {                if (startTime + 2000 < mElapsedTime.milliseconds() && targetPosition <                        getEncoderWheel().getCurrentPosition())                {                    break;                }                final double leftMotorPower;                final double rightMotorPower;                targetPosition = getEncoderWheel().getCurrentPosition() + (5 *                        COUNTS_PER_MILLIMETER);                startTime = mElapsedTime.milliseconds();                leftMotorPower = getRangeDrivePower(power, startingWallDistance, wallDistance) -                        getOdsPowerAdjustment();                rightMotorPower = getRangeDrivePower(power, startingWallDistance, wallDistance) +                        getOdsPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);            }        }        stopDriveMotors();    }    void pressBeaconButton(final double power, final double driveTime)    {        final double startTime = mElapsedTime.milliseconds();        if (opModeIsActive())        {            final int initialGyroHeading = getGyroHeading();            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setPower(power);            mRightDriveMotor.setPower(power);            while (startTime + driveTime > mElapsedTime.milliseconds()                    && opModeIsActive())            {                final boolean isObstacleDetected = isOutsideGyroThreshold(initialGyroHeading,                        MAXIMUM_GYRO_ERROR);                if (isObstacleDetected && initialGyroHeading > getGyroHeading())                {                    drive(power, -50, 40);                    turn(power, 16);                    drive(0.2, 100, 90);                    turn(0.5, -10);                    timeDrive(power, 500);                    break;                }                else if (isObstacleDetected && initialGyroHeading < getGyroHeading())                {                    drive(power, -50, 40);                    turn(power, -16);                    drive(0.2, 100, 90);                    turn(0.5, 10);                    timeDrive(power, 500);                    break;                }            }            stopDriveMotors();        }    }    /**     * Drives for a set amount of time.     *     * @param power     The power the robot should drive at.     * @param driveTime The time in milliseconds that the robot should drive for     */    void timeDrive(final double power, final int driveTime)    {        final double startTime = mElapsedTime.milliseconds();        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setPower(power);            mRightDriveMotor.setPower(power);            while (startTime + driveTime > mElapsedTime.milliseconds() && opModeIsActive())            {                idle();            }        }        stopDriveMotors();    }    void correctHeading(final double power)    {        final int headingError = mTargetGyroHeading - getGyroHeading();        if (Math.abs(headingError) >= MAXIMUM_GYRO_ERROR && opModeIsActive())        {            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isHeadingReached(headingError, MAXIMUM_GYRO_ERROR) && opModeIsActive())            {                final double turnPower = getTurnPower(power, headingError);                mLeftDriveMotor.setPower(-turnPower);                mRightDriveMotor.setPower(turnPower);                idle();            }            correctHeading(power);        }        stopDriveMotors();    }    // Power control    /**     * Generates a parabolic function and slows the robot down while driving     * forwards or backwards using the parameters.     *     * @param driveDistance The distance that the robot is attempting to drive.     * @param power         The maximum power the robot should drive at.     *     * @return The power that the robot should drive at.     */    private double getDrivePower(final double power, final int driveDistance,                                 final int parabolicThreshold)    {        final double encoderDistance = getEncoderWheel().getCurrentPosition();        if (Math.abs(encoderDistance) <                Math.abs(driveDistance) - parabolicThreshold * COUNTS_PER_MILLIMETER)        {            return power * (driveDistance / Math.abs(driveDistance));        }        else        {            final double adjustedPower = ((1 - MINIMUM_DRIVE_POWER) - (1 - power)) * Math.pow(1 -                    Math.abs(Math.abs(encoderDistance) - (Math.abs(driveDistance) -                            parabolicThreshold * COUNTS_PER_MILLIMETER)) /                            (parabolicThreshold * COUNTS_PER_MILLIMETER), 2) + MINIMUM_DRIVE_POWER;            return driveDistance > 0 ?                    Range.clip(adjustedPower, MINIMUM_DRIVE_POWER, 1) :                    Range.clip(-adjustedPower, -1, -MINIMUM_DRIVE_POWER);        }    }    /**     * Generates a parabolic function that slows down that robot as it gets     * closer to its target heading when turning.     *     * @param angleChange The amount of degrees that the robot it turning.     * @param power       The maximum power the robot should turn at.     *     * @return The power the robot should turn at.     */    private double getTurnPower(final double power, final double angleChange)    {        final double adjustedPower = ((1 - MINIMUM_TURN_POWER) - (1 - power)) *                Math.pow(Math.abs(mTargetGyroHeading - getGyroHeading()) / Math.abs(angleChange),                        2) + MINIMUM_TURN_POWER;        return adjustedPower * (angleChange / Math.abs(angleChange));    }    /**     * Creates a parabolic function using the range sensor so that the robot     * slows down as it gets closer to the wall.     *     * @param startingWallDistance The distance we started at the wall from     * @param power                The maximum power the robot should drive at     *     * @return The power should drive at.     */    private double getRangeDrivePower(final double power, final double            startingWallDistance, final double targetDistance)    {        double adjustedPower = ((1 - MINIMUM_DRIVE_POWER) - (1 - power)) *                Math.pow(mLeftRangeSensor.cmUltrasonic() / (startingWallDistance - targetDistance),                        2) + MINIMUM_DRIVE_POWER;        adjustedPower -=                (Math.abs(mTargetGyroHeading - getGyroHeading()) * GYRO_DRIVE_COEFFICIENT * 3);        return Range.clip(adjustedPower, MINIMUM_DRIVE_POWER, power);    }    // Drive Correction    private double getGyroPowerAdjustment()    {        return (mTargetGyroHeading - getGyroHeading()) * GYRO_DRIVE_COEFFICIENT;    }    private double getOdsPowerAdjustment()    {        return (mRightOds.getLightDetected() - mLeftOds.getLightDetected()) * ODS_COEFFICIENT;    }    // Conditions    /**     * Tells when the distance the robot was driving for was reached.     *     * @param driveDistance The target distance the robot was driving for.     *     * @return True if the distance has been reached.     */    private boolean isDriveDistanceReached(final double driveDistance)    {        return Math.abs(getEncoderWheel().getCurrentPosition()) >= Math.abs(driveDistance);    }    private boolean isHeadingReached(final double angleChange, final int threshold)    {        return angleChange > 0 ?                getGyroHeading() > mTargetGyroHeading - threshold :                getGyroHeading() < mTargetGyroHeading + threshold;    }    /**     * Tells if a light has been detected by the optical distance sensors. In     * almost every case this will be used for detecting the lines in front     * of the beacons.     *     * @param lightThreshold The light threshold that a line has been detected.     *     * @return True if a line has been detected.     */    private boolean isLineDetected(final double lightThreshold)    {        return mLeftOds.getLightDetected() > lightThreshold ||                mRightOds.getLightDetected() > lightThreshold;    }    private boolean isLineDetectedOnEdge(final double lightThreshold)    {        return mFrontLeftOds.getLightDetected() > lightThreshold ||                mFrontRightOds.getLightDetected() > lightThreshold;    }    private boolean isWallWithinRangeThreshold(final int rangeThreshold)    {        return mLeftRangeSensor.cmUltrasonic() <= rangeThreshold;    }    boolean isAlignedWithBeacon()    {        return mLeftRangeSensor.cmUltrasonic() > MINIMUM_WALL_DISTANCE;    }    BeaconColor getDetectedColorOnRight()    {        idle();        final double startTime = mElapsedTime.milliseconds();        while (mColorSensor.red() < COLOR_DETECTION_THRESHOLD && mColorSensor.blue() <                COLOR_DETECTION_THRESHOLD && opModeIsActive())        {            if (startTime + MAXIMUM_COLOR_SENSOR_WAIT_TIME <= mElapsedTime.milliseconds())            {                return BeaconColor.UNKNOWN;            }            idle();        }        final int redValue = mColorSensor.red();        final int blueValue = mColorSensor.blue();        if ((redValue == 0 && blueValue == 0) || (redValue == 255 && blueValue == 255))        {            return BeaconColor.ERROR;        }        if (redValue > blueValue)        {            return BeaconColor.COLOR_RED;        }        else if (blueValue > redValue)        {            return BeaconColor.COLOR_BLUE;        }        else        {            return BeaconColor.UNKNOWN;        }    }    private boolean isOutsideGyroThreshold(final int initialHeading, final int threshold)    {        return initialHeading + threshold < getGyroHeading()                || initialHeading - threshold > getGyroHeading();    }    private boolean isLiftBelowMaxHeight()    {        return mLiftMotor1.getCurrentPosition() < MAXIMUM_LIFT_HEIGHT;    }    /**     * Stops both drive motors and resets the encoder wheel.     */    private void stopDriveMotors()    {        mLeftDriveMotor.setPower(0.0);        mRightDriveMotor.setPower(0.0);        getEncoderWheel().setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        idle();    }    // Actions    /**     * Sets the power for both lift motors     *     * @param power The power the lift should run at.     */    void setLiftPower(final double power)    {        if (opModeIsActive())        {            if (power > 0 && isLiftBelowMaxHeight() || power < 0 && isLiftElevated())            {                mLiftMotor1.setPower(power);            }            else if (power > 0 && !isLiftBelowMaxHeight() || power == 0)            {                mLiftMotor1.setPower(0.0);            }            else if (power < 0 && !isLiftElevated())            {                resetLiftPosition();            }            mLiftMotor2.setPower(mLiftMotor1.getPower());        }    }    void launchBall(final int delay)    {        if (opModeIsActive())        {            liftBallDeployer();            setButtonPusherPosition(ButtonPusherPosition.NEUTRAL_POSITION);            dropCapBallGrabber();            idle();            sleep(delay);            dropBallDeployer();        }    }    void launchBalls(final int targetSpeed, final int nBalls)    {        if (opModeIsActive())        {            mBallLauncher.setPower(1.00);            while(opModeIsActive())            {                double initialTime = mElapsedTime.milliseconds();                int initialDisplacement = mBallLauncher.getCurrentPosition();                idle();                double finalTime = mElapsedTime.milliseconds();                int finalDisplacement = mBallCollector.getCurrentPosition();                //mBallLauncherSpeed            }        }    }    void liftBallDeployer()    {        if (opModeIsActive())            mBallDeployer.setPosition(0.75);    }    void dropBallDeployer()    {        if (opModeIsActive())            mBallDeployer.setPosition(1.0);    }    void startBallCollector()    {        if (opModeIsActive())            mBallCollector.setPower(1.0);    }    void stopBallCollector()    {        if (opModeIsActive())            mBallCollector.setPower(0.0);    }    void reverseBallCollector()    {        if (opModeIsActive())            mBallCollector.setPower(-1.0);    }    void liftCapBallGrabber()    {        if (opModeIsActive())            mCapBallGrabber.setPosition(0.85);    }    void clampCapBallGrabber()    {        if (opModeIsActive())            mCapBallGrabber.setPosition(0.5);    }    void dropCapBallGrabber()    {        if (opModeIsActive())            mCapBallGrabber.setPosition(0.0);    }    void startBallLauncherAtLowPower()    {        if (opModeIsActive())            mBallLauncher.setPower(0.55);    }    void startBallLauncherAtHighPower()    {        if (opModeIsActive())            mBallLauncher.setPower(0.75);    }    void stopBallLauncher()    {        mBallLauncher.setPower(0.0);    }    void setButtonPusherPosition(final ButtonPusherPosition position)    {        if (opModeIsActive())        {            switch (position)            {                case LEFT_POSITION:                    mButtonPusher.setPosition(0.0);                    break;                case NEUTRAL_POSITION:                    mButtonPusher.setPosition(0.3);                    break;                case RIGHT_POSITION:                    mButtonPusher.setPosition(0.8);                    break;            }        }    }    /**     * Calculate the gyro heading by taking the raw gyro heading taken from     * the sensor and converting it into a more usable value.     *     * @return The gyro heading.     */    private int getGyroHeading()    {        final int rawGyroHeading = mGyroSensor.getHeading();        // 0->360        if (rawGyroHeading - 180 > mLastRawGyroHeading)        {            mGyroHeading = mGyroHeading + rawGyroHeading - 360 - mLastRawGyroHeading;        }        // 359->0        else if (rawGyroHeading + 180 < mLastRawGyroHeading)        {            mGyroHeading = mGyroHeading + rawGyroHeading + 360 - mLastRawGyroHeading;        }        else        {            mGyroHeading = mGyroHeading + rawGyroHeading - mLastRawGyroHeading;        }        mLastRawGyroHeading = rawGyroHeading;        return mGyroHeading;    }    // Getters, setters and other    void interruptibleWait(final int waitTime)    {        final double startTime  = mElapsedTime.milliseconds();        while (startTime + waitTime > mElapsedTime.milliseconds() && opModeIsActive())        {            idle();        }    }    DcMotorSimple getLeftDriveMotor()    {        return mLeftDriveMotor;    }    DcMotorSimple getRightDriveMotor()    {        return mRightDriveMotor;    }    int getLiftPosition()    {        return mLiftMotor1.getCurrentPosition();    }    private boolean isLiftElevated()    {        return !mLiftSensor.isPressed();    }    private void resetLiftPosition()    {        mLiftMotor1.setPower(0.0);        mLiftMotor2.setPower(0.0);        mLiftMotor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mLiftMotor1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);    }    private DcMotor getEncoderWheel()    {        return mRightDriveMotor;    }    DcMotor getBallLauncher()    {        return mBallLauncher;    }    private void changeTargetGyroHeading(final int headingChange)    {        mTargetGyroHeading += headingChange;    }    private int computeAdjustedPostLineDistance()    {        final int gyroHeading = getGyroHeading();        return (int) Math                .round(Math.sin(Math.toRadians(ANGLE_BETWEEN_ODS_SENSORS - Math.abs(gyroHeading))) *                        (DISTANCE_BETWEEN_ODS_SENSORS /                                Math.sin(Math.toRadians(90 + Math.abs(gyroHeading)))));    }    enum BeaconColor    {        COLOR_RED, COLOR_BLUE, UNKNOWN, ERROR    }    enum ButtonPusherPosition    {        LEFT_POSITION, RIGHT_POSITION, NEUTRAL_POSITION    }}