package org.firstinspires.ftc.teamcode;import android.support.annotation.Nullable;import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;import com.qualcomm.robotcore.hardware.ColorSensor;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.DcMotorSimple;import com.qualcomm.robotcore.hardware.GyroSensor;import com.qualcomm.robotcore.hardware.OpticalDistanceSensor;import com.qualcomm.robotcore.hardware.Servo;import com.qualcomm.robotcore.hardware.TouchSensor;import com.qualcomm.robotcore.util.ElapsedTime;import com.qualcomm.robotcore.util.Range;import org.firstinspires.ftc.teamcode.enums.BeaconColor;import org.firstinspires.ftc.teamcode.enums.ButtonPusherPosition;import org.firstinspires.ftc.teamcode.enums.ColorSensorPosition;abstract class Archimedes extends LinearOpMode{    static final int DEFAULT_WALL_DISTANCE = 12;    static final double MINIMUM_DRIVE_POWER = 0.15;    static final double MINIMUM_TURN_POWER = 0.475;    static final double MAXIMUM_LIFT_HEIGHT = 26800;    static final double MAXIMUM_SLOW_POWER_DRIVE = 0.30;    static final double MAXIMUM_SLOW_POWER_TURN = 0.6;    static final int BALL_LAUNCH_WAIT_TIME = 200;    static final int POST_LAUNCH_WAIT_TIME = 700;    private static final int DEFAULT_BALL_LAUNCHER_SPEED = 1650;    private static final int POST_LINE_DISTANCE = 50;    private static final int MAXIMUM_COLOR_SENSOR_WAIT_TIME = 1000;    private static final double DEFAULT_LINE_THRESHOLD = 0.15;    private static final int COLOR_DETECTION_THRESHOLD = 5;    private static final int MINIMUM_WALL_DISTANCE = 4;    private static final int DEFAULT_TURN_THRESHOLD = 6;    private static final int MAXIMUM_GYRO_ERROR = 4;    private static final double GYRO_DRIVE_COEFFICIENT = 0.04;    private static final double ODS_COEFFICIENT = 1.0;    private static final double DISTANCE_BETWEEN_ODS_SENSORS = 213;    private static final double ANGLE_BETWEEN_ODS_SENSORS = 34;    private static final int COUNTS_PER_REVOLUTION = 1440;    private static final double ENCODER_WHEEL_DIAMETER = 50.2;    private static final double COUNTS_PER_MILLIMETER = COUNTS_PER_REVOLUTION            / (ENCODER_WHEEL_DIAMETER * Math.PI);    Thread BallLauncherSpeedControlThread;    private final ElapsedTime mElapsedTime = new ElapsedTime();    private int mLastRawGyroHeading = 0;    private int mGyroHeading = 0;    private int mTargetGyroHeading = 0;    private DcMotor mLeftDriveMotor;    private DcMotor mRightDriveMotor;    private DcMotor mBallLauncher;    private DcMotor mBallCollector;    private DcMotor mLiftMotor1;    private DcMotor mLiftMotor2;    private Servo mBallDeployer;    private Servo mCapBallGrabber;    private Servo mButtonPusher;    private ModernRoboticsI2cRangeSensor mLeftRangeSensor;    private OpticalDistanceSensor mLeftOds;    private OpticalDistanceSensor mRightOds;    private OpticalDistanceSensor mFrontLeftOds;    private OpticalDistanceSensor mFrontRightOds;    private ColorSensor mLeftColorSensor;    private ColorSensor mRightColorSensor;    private TouchSensor mLiftSensor;    private GyroSensor mGyroSensor;    private Runnable ballLauncherControl;    boolean shouldRecordBallLauncherIntegral = true;    void initializeArchimedes()    {        mLeftDriveMotor = hardwareMap.dcMotor.get("left motor");        mLeftDriveMotor.setDirection(DcMotor.Direction.REVERSE);        mLeftDriveMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mLeftDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        mRightDriveMotor = hardwareMap.dcMotor.get("right motor");        mRightDriveMotor.setDirection(DcMotor.Direction.FORWARD);        mRightDriveMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mRightDriveMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        mBallLauncher = hardwareMap.dcMotor.get("ball launcher");        mBallLauncher.setDirection(DcMotor.Direction.REVERSE);        mBallLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mBallLauncher.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        mBallLauncher.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);        mBallCollector = hardwareMap.dcMotor.get("ball collector");        mBallCollector.setDirection(DcMotor.Direction.REVERSE);        mBallCollector.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);        mLiftMotor1 = hardwareMap.dcMotor.get("lift motor 1");        mLiftMotor1.setDirection(DcMotorSimple.Direction.REVERSE);        mLiftMotor2 = hardwareMap.dcMotor.get("lift motor 2");        mLiftMotor2.setDirection(DcMotorSimple.Direction.REVERSE);        mCapBallGrabber = hardwareMap.servo.get("cap ball grabber");        mCapBallGrabber.setDirection(Servo.Direction.FORWARD);        dropCapBallGrabber();        mButtonPusher = hardwareMap.servo.get("button pusher");        mButtonPusher.setDirection(Servo.Direction.FORWARD);        setButtonPusherPosition(ButtonPusherPosition.NEUTRAL_POSITION);        mBallDeployer = hardwareMap.servo.get("ball deployer");        mBallDeployer.setDirection(Servo.Direction.FORWARD);        mLeftColorSensor = hardwareMap.colorSensor.get("left color sensor");        mLeftColorSensor.enableLed(false);        mRightColorSensor = hardwareMap.colorSensor.get("right color sensor");        mRightColorSensor.enableLed(false);        mLeftRangeSensor = hardwareMap                .get(ModernRoboticsI2cRangeSensor.class, "left range sensor");        mLeftOds = hardwareMap.opticalDistanceSensor.get("left ODS");        mRightOds = hardwareMap.opticalDistanceSensor.get("right ODS");        mFrontLeftOds = hardwareMap.opticalDistanceSensor.get("front left ODS");        mFrontRightOds = hardwareMap.opticalDistanceSensor.get("front right ODS");        mLiftSensor = hardwareMap.touchSensor.get("lift sensor");        mGyroSensor = hardwareMap.gyroSensor.get("gyro");        mGyroSensor.calibrate();    }    void waitForGyroCalibration()    {        telemetry.addData(">", "Calibrating gyro...");        telemetry.update();        idle();        sleep(1000);        while (mGyroSensor.isCalibrating() && !isStopRequested())        {            idle();        }        telemetry.addData(">", "Archimedes ready!");        telemetry.update();    }    void startArchimedes()    {        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            setButtonPusherPosition(ButtonPusherPosition.NEUTRAL_POSITION);            dropCapBallGrabber();            dropBallDeployer();            telemetry.addData(">", "Archimedes running...");            telemetry.update();            mGyroSensor.resetZAxisIntegrator();            mElapsedTime.reset();        }    }    void drive(final double power, final int distance, final int slowDownThreshold)    {        final int encoderDistance = (int) Math.round(distance * COUNTS_PER_MILLIMETER);        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isDriveDistanceReached(encoderDistance) && opModeIsActive())            {                final double leftMotorPower;                final double rightMotorPower;                leftMotorPower = getDrivePower(power, encoderDistance, slowDownThreshold) -                        getGyroPowerAdjustment();                rightMotorPower = getDrivePower(power, encoderDistance, slowDownThreshold) +                        getGyroPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);                idle();            }        }        stopDriveMotors();    }    void turn(final double power, final int angleChange)    {        if (opModeIsActive())        {            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            changeTargetGyroHeading(angleChange);            while (!isHeadingReached(angleChange, DEFAULT_TURN_THRESHOLD) && opModeIsActive())            {                final double turnPower = getTurnPower(power, angleChange);                mLeftDriveMotor.setPower(-turnPower);                mRightDriveMotor.setPower(turnPower);            }        }        stopDriveMotors();    }    void driveToLine(final double power, final int maximumDistance, final int slowdownThreshold)    {        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);        final int maxEncoderDistance = (int) Math.round(COUNTS_PER_MILLIMETER * maximumDistance);        if (opModeIsActive())        {            int adjustedPostLineDist = 0;            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isDriveDistanceReached(maxEncoderDistance) &&                    !isLineDetected(DEFAULT_LINE_THRESHOLD) && opModeIsActive())            {                final double leftMotorPower;                final double rightMotorPower;                leftMotorPower = getDrivePower(power, maxEncoderDistance, slowdownThreshold) -                        getGyroPowerAdjustment();                rightMotorPower = getDrivePower(power, maxEncoderDistance, slowdownThreshold) +                        getGyroPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);                if (getEncoderWheel().getCurrentPosition() > maxEncoderDistance / 8)                {                    if (isLineDetected(DEFAULT_LINE_THRESHOLD))                    {                        adjustedPostLineDist = POST_LINE_DISTANCE;                        break;                    }                    else if (isLineDetectedOnEdge(DEFAULT_LINE_THRESHOLD / 3))                    {                        adjustedPostLineDist = computeAdjustedPostLineDistance();                        adjustedPostLineDist += POST_LINE_DISTANCE;                        break;                    }                }            }            idle();            adjustedPostLineDist = (int) Math.round(adjustedPostLineDist * COUNTS_PER_MILLIMETER);            final int totalDriveDistance =                    Math.round(getEncoderWheel().getCurrentPosition() + adjustedPostLineDist);            while (!isDriveDistanceReached(totalDriveDistance) && opModeIsActive())            {                final double leftMotorPower;                final double rightMotorPower;                leftMotorPower = getDrivePower(power, totalDriveDistance, slowdownThreshold) -                        getGyroPowerAdjustment();                rightMotorPower = getDrivePower(power, totalDriveDistance, slowdownThreshold) +                        getGyroPowerAdjustment();                mLeftDriveMotor.setPower(leftMotorPower);                mRightDriveMotor.setPower(rightMotorPower);                idle();            }        }        stopDriveMotors();        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);    }    private void driveFromWall(final double power, final int objectDistance)    {        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isObjectOutsideRangeThreshold(objectDistance) && opModeIsActive())            {                mLeftDriveMotor.setPower(power);                mRightDriveMotor.setPower(power);                idle();            }        }        stopDriveMotors();        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);    }    void followLineToWall(final double power, final int wallDistance)    {        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            double targetPosition =                    getEncoderWheel().getCurrentPosition() / COUNTS_PER_MILLIMETER + 2;            double startingStallTime = mElapsedTime.milliseconds();            final double startingDistance = mLeftRangeSensor.cmUltrasonic();            while (!isObjectWithinRangeThreshold(wallDistance) && opModeIsActive())            {                if (startingStallTime + 500 <= mElapsedTime.milliseconds() &&                        mLeftRangeSensor.cmUltrasonic() < wallDistance + 2)                {                    if (targetPosition >                            getEncoderWheel().getCurrentPosition() / COUNTS_PER_MILLIMETER)                    {                        return;                    }                    else                    {                        targetPosition =                                getEncoderWheel().getCurrentPosition() / COUNTS_PER_MILLIMETER + 5;                        startingStallTime = mElapsedTime.milliseconds();                    }                }                if (isLineDetected(DEFAULT_LINE_THRESHOLD / 5))                {                    final double leftMotorPower;                    final double rightMotorPower;                    leftMotorPower =                            Range.clip(getRangeDrivePower(power, startingDistance, wallDistance) -                                    getOdsPowerAdjustment(), power, 0.4);                    rightMotorPower =                            Range.clip(getRangeDrivePower(power, startingDistance, wallDistance) +                                    getOdsPowerAdjustment(), power, 0.4);                    mLeftDriveMotor.setPower(leftMotorPower);                    mRightDriveMotor.setPower(rightMotorPower);                }                else                {                    while (!isLineDetected(DEFAULT_LINE_THRESHOLD / 3) && opModeIsActive())                    {                        if (getGyroHeading() > 0)                        {                            mLeftDriveMotor.setPower(-0.6);                            mRightDriveMotor.setPower(0.6);                        }                        else                        {                            mLeftDriveMotor.setPower(0.6);                            mRightDriveMotor.setPower(-0.6);                        }                    }                }            }        }        stopDriveMotors();        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);    }    void pressBeaconButton(final double power, final int driveTime,                           final ButtonPusherPosition pusherPosition)    {        if (pusherPosition != getButtonPusherPosition())        {            setButtonPusherPosition(pusherPosition);            interruptibleSleep(300);        }        final double startTime = mElapsedTime.milliseconds();        if (opModeIsActive())        {            final int initialGyroHeading = getGyroHeading();            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setPower(power);            mRightDriveMotor.setPower(power);            while (startTime + driveTime > mElapsedTime.milliseconds()                    && opModeIsActive())            {                final boolean isObstacleDetected = isOutsideGyroThreshold(initialGyroHeading, MAXIMUM_GYRO_ERROR);                if (isObstacleDetected && initialGyroHeading > getGyroHeading())                {                    drive(0.2, -65, 50);                    turn(0.5, 19);                    drive(0.2, 75, 75);                    turn(0.5, -19);                    timeDrive(power, driveTime);                    break;                }                else if (isObstacleDetected && initialGyroHeading < getGyroHeading())                {                    drive(0.3, -65, 50);                    turn(0.5, -19);                    drive(0.3, 75, 75);                    turn(0.5, 19);                    timeDrive(power, driveTime);                    break;                }            }            stopDriveMotors();            drive(0.65, -60, 60);            setButtonPusherPosition(ButtonPusherPosition.LEFT_POSITION);        }    }    void timeDrive(final double power, final int driveTime)    {        final double startTime = mElapsedTime.milliseconds();        if (opModeIsActive())        {            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setPower(power);            mRightDriveMotor.setPower(power);            while (startTime + driveTime > mElapsedTime.milliseconds() && opModeIsActive())            {                idle();            }        }        stopDriveMotors();    }    void correctHeading(final double power)    {        final int headingError = mTargetGyroHeading - getGyroHeading();        if (Math.abs(headingError) >= MAXIMUM_GYRO_ERROR && opModeIsActive())        {            mRightDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            mLeftDriveMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);            while (!isHeadingReached(headingError, MAXIMUM_GYRO_ERROR) && opModeIsActive())            {                final double turnPower = getTurnPower(power, headingError);                mLeftDriveMotor.setPower(-turnPower);                mRightDriveMotor.setPower(turnPower);                idle();            }            correctHeading(power);        }        stopDriveMotors();    }    private double getDrivePower(final double power, final int driveDistance,                                 final int parabolicThreshold)    {        final double encoderDistance = getEncoderWheel().getCurrentPosition();        if (Math.abs(encoderDistance) <                Math.abs(driveDistance) - parabolicThreshold * COUNTS_PER_MILLIMETER)        {            return power * (driveDistance / Math.abs(driveDistance));        }        else        {            final double adjustedPower = ((1 - MINIMUM_DRIVE_POWER) - (1 - power)) * Math.pow(1 -                    Math.abs(Math.abs(encoderDistance) - (Math.abs(driveDistance) -                            parabolicThreshold * COUNTS_PER_MILLIMETER)) /                            (parabolicThreshold * COUNTS_PER_MILLIMETER), 2) + MINIMUM_DRIVE_POWER;            return driveDistance > 0 ?                    Range.clip(adjustedPower, MINIMUM_DRIVE_POWER, 1) :                    Range.clip(-adjustedPower, -1, -MINIMUM_DRIVE_POWER);        }    }    private double getRangeDrivePower(final double power, final double            startingWallDistance, final double targetDistance)    {        double adjustedPower = ((1 - MINIMUM_DRIVE_POWER) - (1 - power)) * Math.pow((mLeftRangeSensor.cmUltrasonic() / (startingWallDistance - targetDistance)),                2) + MINIMUM_DRIVE_POWER;        adjustedPower -=                (Math.abs(mTargetGyroHeading - getGyroHeading()) * GYRO_DRIVE_COEFFICIENT * 3);        return Range.clip(adjustedPower, MINIMUM_DRIVE_POWER, power);    }    private double getTurnPower(final double power, final double angleChange)    {        final double adjustedPower = ((1 - MINIMUM_TURN_POWER) - (1 - power)) *                Math.pow(Math.abs(mTargetGyroHeading - getGyroHeading()) / Math.abs(angleChange),                        2) + MINIMUM_TURN_POWER;        return adjustedPower * (angleChange / Math.abs(angleChange));    }    private double getGyroPowerAdjustment()    {        return (mTargetGyroHeading - getGyroHeading()) * GYRO_DRIVE_COEFFICIENT;    }    private double getOdsPowerAdjustment()    {        return (mRightOds.getLightDetected() - mLeftOds.getLightDetected()) * ODS_COEFFICIENT;    }    private boolean isDriveDistanceReached(final double driveDistance)    {        return Math.abs(getEncoderWheel().getCurrentPosition()) >= Math.abs(driveDistance);    }    private boolean isHeadingReached(final double angleChange, final int threshold)    {        return angleChange > 0 ?                getGyroHeading() > mTargetGyroHeading - threshold :                getGyroHeading() < mTargetGyroHeading + threshold;    }    private boolean isLineDetected(final double lightThreshold)    {        return mLeftOds.getLightDetected() > lightThreshold ||                mRightOds.getLightDetected() > lightThreshold;    }    private boolean isLineDetectedOnEdge(final double lightThreshold)    {        return mFrontLeftOds.getLightDetected() > lightThreshold ||                mFrontRightOds.getLightDetected() > lightThreshold;    }    private boolean isObjectWithinRangeThreshold(final int rangeThreshold)    {        return mLeftRangeSensor.cmUltrasonic() <= rangeThreshold;    }    private boolean isObjectOutsideRangeThreshold(final int rangeThreshold)    {        return mLeftRangeSensor.cmUltrasonic() >= rangeThreshold;    }    boolean isAlignedWithBeacon()    {        return mLeftRangeSensor.cmUltrasonic() > MINIMUM_WALL_DISTANCE                && isLineDetected(DEFAULT_LINE_THRESHOLD);    }    BeaconColor getDetectedColor(ColorSensorPosition sensorPosition)    {        idle();        final double startTime = mElapsedTime.milliseconds();        switch (sensorPosition)        {            case LEFT_SENSOR:                while (mLeftColorSensor.red() < COLOR_DETECTION_THRESHOLD &&                        mLeftColorSensor.blue() < COLOR_DETECTION_THRESHOLD && opModeIsActive())                {                    if (startTime + MAXIMUM_COLOR_SENSOR_WAIT_TIME <= mElapsedTime.milliseconds())                    {                        return BeaconColor.UNKNOWN;                    }                    idle();                }                break;            case RIGHT_SENSOR:                while (mRightColorSensor.red() < COLOR_DETECTION_THRESHOLD &&                        mRightColorSensor.blue() < COLOR_DETECTION_THRESHOLD && opModeIsActive())                {                    if (startTime + MAXIMUM_COLOR_SENSOR_WAIT_TIME <= mElapsedTime.milliseconds())                    {                        return BeaconColor.UNKNOWN;                    }                    idle();                }                break;        }        final int redValue = (sensorPosition == ColorSensorPosition.LEFT_SENSOR ?                mLeftColorSensor.red() : mRightColorSensor.red());        final int blueValue = (sensorPosition == ColorSensorPosition.LEFT_SENSOR ?                mLeftColorSensor.blue() : mRightColorSensor.blue());        if ((redValue == 0 && blueValue == 0) || (redValue == 255 && blueValue == 255))        {            return BeaconColor.ERROR;        }        else if (redValue > blueValue)        {            return BeaconColor.COLOR_RED;        }        else if (blueValue > redValue)        {            return BeaconColor.COLOR_BLUE;        }        else        {            return BeaconColor.UNKNOWN;        }    }    private boolean isOutsideGyroThreshold(final int initialHeading, final int threshold)    {        return initialHeading + threshold < getGyroHeading()                || initialHeading - threshold > getGyroHeading();    }    private boolean isLiftBelowMaxHeight()    {        return mLiftMotor1.getCurrentPosition() < MAXIMUM_LIFT_HEIGHT;    }    private void stopDriveMotors()    {        mLeftDriveMotor.setPower(0.0);        mRightDriveMotor.setPower(0.0);        getEncoderWheel().setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        idle();    }    void setLiftPower(final double power)    {        if (opModeIsActive())        {            if (power > 0 && isLiftBelowMaxHeight() || power < 0 && isLiftElevated())            {                mLiftMotor1.setPower(power);            }            else if (power > 0 && !isLiftBelowMaxHeight() || power == 0)            {                mLiftMotor1.setPower(0.0);            }            else if (power < 0 && !isLiftElevated())            {                resetLiftPosition();            }            mLiftMotor2.setPower(mLiftMotor1.getPower());        }    }    void liftBallDeployer()    {        if (opModeIsActive())            mBallDeployer.setPosition(0.75);    }    void dropBallDeployer()    {        if (opModeIsActive())            mBallDeployer.setPosition(1.0);    }    void startBallCollector()    {        if (opModeIsActive())            mBallCollector.setPower(1.0);    }    void stopBallCollector()    {        if (opModeIsActive())            mBallCollector.setPower(0.0);    }    void reverseBallCollector()    {        if (opModeIsActive())            mBallCollector.setPower(-1.0);    }    void liftCapBallGrabber()    {        if (opModeIsActive())            mCapBallGrabber.setPosition(0.85);    }    void clampCapBallGrabber()    {        if (opModeIsActive())            mCapBallGrabber.setPosition(0.5);    }    void dropCapBallGrabber()    {        if (opModeIsActive())            mCapBallGrabber.setPosition(0.0);    }    private void launchBall()    {        if (opModeIsActive())        {            liftBallDeployer();            interruptibleSleep(BALL_LAUNCH_WAIT_TIME);            dropBallDeployer();        }    }    void launchBalls()    {        if (opModeIsActive())        {            waitForStableBallLauncherSpeed();            shouldRecordBallLauncherIntegral = false;            for (int i = 0; i < 2; i++)            {                launchBall();                interruptibleSleep(POST_LAUNCH_WAIT_TIME);            }            shouldRecordBallLauncherIntegral = true;        }    }    private double getBallLauncherSpeed() throws InterruptedException    {        final int initialPosition = mBallLauncher.getCurrentPosition();        Thread.sleep(50);        final int finalPosition = mBallLauncher.getCurrentPosition();        return (finalPosition - initialPosition) / 0.05;    }    private void waitForStableBallLauncherSpeed()    {        BallLauncherSpeedControlThread.setPriority(Thread.MAX_PRIORITY);        interruptibleSleep(1500);        BallLauncherSpeedControlThread.setPriority(Thread.NORM_PRIORITY + 1);    }    void startBallLauncher()    {        if (ballLauncherControl == null)        {            ballLauncherControl = new Runnable()            {                private static final double BALL_LAUNCHER_SPEED_PROPORTIONAL_GAIN = 0.000460000;                private static final double BALL_LAUNCHER_SPEED_INTEGRAL_GAIN = 0.000750000;                private static final double BALL_LAUNCHER_SPEED_DERIVATIVE_GAIN = 0.00000524;                public void run()                {                    double mBallLauncherSpeedIntegral = 0;                    double mPreviousBallLauncherSpeedError = 0;                    while (opModeIsActive())                    {                        final double deltaTime = 0.05;                        final double currentSpeed;                        try                        {                            currentSpeed = getBallLauncherSpeed();                        }                        catch (InterruptedException e)                        {                            break;                        }                        final double ballLauncherSpeedError =                                DEFAULT_BALL_LAUNCHER_SPEED - currentSpeed;                        if(shouldRecordBallLauncherIntegral)                            mBallLauncherSpeedIntegral += ballLauncherSpeedError * deltaTime;                        final double ballLauncherSpeedDerivative =                                (ballLauncherSpeedError - mPreviousBallLauncherSpeedError) /                                        deltaTime;                        final double P =                                ballLauncherSpeedError * BALL_LAUNCHER_SPEED_PROPORTIONAL_GAIN;                        final double I =                                mBallLauncherSpeedIntegral * BALL_LAUNCHER_SPEED_INTEGRAL_GAIN;                        final double D =                                ballLauncherSpeedDerivative * BALL_LAUNCHER_SPEED_DERIVATIVE_GAIN;                        final double powerOutput = Range.clip(P + I + D, -1.0, 1.0);                        mBallLauncher.setPower(powerOutput);                        mPreviousBallLauncherSpeedError = ballLauncherSpeedError;                    }                    mBallLauncher.setPower(0.0);                }            };        }        if (BallLauncherSpeedControlThread == null)        {            BallLauncherSpeedControlThread = new Thread(ballLauncherControl);            BallLauncherSpeedControlThread.setPriority(Thread.NORM_PRIORITY + 1);            BallLauncherSpeedControlThread.setName("Ball Launcher Speed Control Thread");            BallLauncherSpeedControlThread.start();        }        else if (!BallLauncherSpeedControlThread.isAlive())        {            BallLauncherSpeedControlThread.setPriority(Thread.NORM_PRIORITY + 1);            BallLauncherSpeedControlThread.start();        }    }    void stopBallLauncher()    {        if (BallLauncherSpeedControlThread != null && BallLauncherSpeedControlThread.isAlive())        {            BallLauncherSpeedControlThread.interrupt();            try            {                BallLauncherSpeedControlThread.join();                BallLauncherSpeedControlThread = null;            }            catch (InterruptedException e)            {                mBallLauncher.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);                mBallLauncher.setPower(0.0);                mBallLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);            }        }    }    @Nullable    private ButtonPusherPosition getButtonPusherPosition()    {        if (mButtonPusher.getPosition() >= 0.0 && mButtonPusher.getPosition() < 0.25)        {            return ButtonPusherPosition.LEFT_POSITION;        }        else if (mButtonPusher.getPosition() >= 0.25 && mButtonPusher.getPosition() <= .75)        {            return ButtonPusherPosition.NEUTRAL_POSITION;        }        else if (mButtonPusher.getPosition() > 0.75 && mButtonPusher.getPosition() <= 1.0)        {            return ButtonPusherPosition.RIGHT_POSITION;        }        else        {            return null;        }    }    void setButtonPusherPosition(final ButtonPusherPosition position)    {        if (opModeIsActive())        {            switch (position)            {                case LEFT_POSITION:                    mButtonPusher.setPosition(0.0);                    break;                case NEUTRAL_POSITION:                    mButtonPusher.setPosition(0.5);                    break;                case RIGHT_POSITION:                    mButtonPusher.setPosition(1.0);                    break;            }        }    }    private int getGyroHeading()    {        final int rawGyroHeading = mGyroSensor.getHeading();        if (rawGyroHeading - 180 > mLastRawGyroHeading)        {            mGyroHeading = mGyroHeading + rawGyroHeading - 360 - mLastRawGyroHeading;        }        else if (rawGyroHeading + 180 < mLastRawGyroHeading)        {            mGyroHeading = mGyroHeading + rawGyroHeading + 360 - mLastRawGyroHeading;        }        else        {            mGyroHeading = mGyroHeading + rawGyroHeading - mLastRawGyroHeading;        }        mLastRawGyroHeading = rawGyroHeading;        return mGyroHeading;    }    void interruptibleSleep(final int waitTime)    {        final double startTime = mElapsedTime.milliseconds();        while (startTime + waitTime > mElapsedTime.milliseconds() && opModeIsActive()                && !Thread.interrupted())        {            sleep(1);        }    }    DcMotorSimple getLeftDriveMotor()    {        return mLeftDriveMotor;    }    DcMotorSimple getRightDriveMotor()    {        return mRightDriveMotor;    }    int getLiftPosition()    {        return mLiftMotor1.getCurrentPosition();    }    private boolean isLiftElevated()    {        return !mLiftSensor.isPressed();    }    void withdrawFromBeacon()    {        setButtonPusherPosition(ButtonPusherPosition.NEUTRAL_POSITION);        driveFromWall(-0.5, 20);    }    void correctBeacon()    {        setButtonPusherPosition(ButtonPusherPosition.NEUTRAL_POSITION);        interruptibleSleep(5500);        pressBeaconButton(0.65, 500, ButtonPusherPosition.NEUTRAL_POSITION);    }    private void resetLiftPosition()    {        mLiftMotor1.setPower(0.0);        mLiftMotor2.setPower(0.0);        mLiftMotor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);        mLiftMotor1.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);    }    private DcMotor getEncoderWheel()    {        return mRightDriveMotor;    }    private void changeTargetGyroHeading(final int headingChange)    {        mTargetGyroHeading += headingChange;    }    private int computeAdjustedPostLineDistance()    {        final int gyroHeading = getGyroHeading();        return (int) Math                .round(Math.sin(Math.toRadians(ANGLE_BETWEEN_ODS_SENSORS - Math.abs(gyroHeading))) *                        (DISTANCE_BETWEEN_ODS_SENSORS /                                Math.sin(Math.toRadians(90 + Math.abs(gyroHeading)))));    }    boolean isEndGameActive()    {        return mElapsedTime.seconds() > 90;    }}